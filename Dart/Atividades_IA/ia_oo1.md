
---

*Obs 1: O paradigma de orienta√ß√£o a objetos √© um dos paradigmas mais famosos e usados no mundo da programa√ß√£o. 
Grande parte de seu sucesso vem da facilidade para abstrair conceitos concretos e convert√™-los em linhas de c√≥digo*

### **1. Quais s√£o os principais conceitos da orienta√ß√£o a objetos?**
Os principais conceitos da **Programa√ß√£o Orientada a Objetos (POO)** s√£o:
- **Encapsulamento**: Proteger dados dentro de uma classe, controlando o acesso por meio de m√©todos.
- **Heran√ßa**: Criar novas classes baseadas em outras, reutilizando c√≥digo e promovendo especializa√ß√£o.
- **Polimorfismo**: Permitir que diferentes classes tenham m√©todos com o mesmo nome, mas comportamentos diferentes.
- **Abstra√ß√£o**: Esconder detalhes complexos e expor apenas funcionalidades essenciais.

---

*Obs 2: Para mim, a modularidade e a delega√ß√£o da orienta√ß√£o a objetos √© incr√≠vel. Transformar grandes blocos de c√≥digo
em pequenos trechos de c√≥digo utilizando classes, interfaces e objetos √© muito √∫til*

### **2. Quais as vantagens de usar orienta√ß√£o a objetos em compara√ß√£o com outras formas de programa√ß√£o?**
- **Reutiliza√ß√£o de c√≥digo**: Heran√ßa permite aproveitar c√≥digo existente.
- **Organiza√ß√£o e modularidade**: Classes deixam o c√≥digo mais estruturado.
- **Facilidade de manuten√ß√£o**: Altera√ß√µes podem ser feitas em classes sem afetar o resto do c√≥digo.
- **Escalabilidade**: C√≥digo mais preparado para crescer sem ficar desorganizado.

---

*Obs 3: Classe √© a defini√ß√£o dos atributos e comportamentos de um objeto. J√° os objetos s√£o a implementa√ß√£o das classes.
A partir desses conceitos, a orienta√ß√£o a objetos torna-se poss√≠vel*

### **3. O que √© uma 'classe' e como ela se relaciona com 'objetos'?**
- **Classe**: Um modelo (molde) para criar objetos. Define atributos (dados) e m√©todos (comportamento).
- **Objeto**: Uma inst√¢ncia de uma classe, ou seja, uma entidade real baseada no modelo da classe.

Exemplo:
```dart
class Carro {
  String marca;
  int ano;
  
  Carro(this.marca, this.ano);
}

void main() {
  Carro meuCarro = Carro("Toyota", 2022); // Objeto da classe Carro
}
```

---

*Obs 4: Eu tenho um costume de chamar os m√©todos de fun√ß√µes, mesmo sabendo que s√£o coisas diferentes.*

### **4. O que s√£o 'm√©todos' e como eles funcionam dentro de uma classe?**
M√©todos s√£o **fun√ß√µes dentro de uma classe** que definem o comportamento dos objetos.

Exemplo:
```dart
class Pessoa {
  String nome;
  
  Pessoa(this.nome);
  
  void falar() {
    print("Ol√°, meu nome √© $nome");
  }
}

void main() {
  Pessoa p = Pessoa("Carlos");
  p.falar(); // Chamada do m√©todo
}
```

---

*Obs 5: √â importante saber se o m√©todo ou atributo acessado √© vis√≠vel para o c√≥digo que voc√™ est√° escrevendo, isto √©,
se √© p√∫blico ou privado (encapsulamento), pois caso seja feita a consulta de um membro privado de uma classe em 
outra classe/arquivo, um erro ser√° lan√ßado*

### **5. Como posso acessar os m√©todos de um objeto em Dart?**
Voc√™ pode acessar m√©todos usando a **nota√ß√£o de ponto (`.`)**:
```dart
Carro meuCarro = Carro("Ford", 2021);
meuCarro.acelerar(); // Chamando o m√©todo 'acelerar'
```

---

*Obs 6: Fundamentais para manter a coer√™ncia do c√≥digo e evitar problemas de seguran√ßa*

### **6. Qual a diferen√ßa entre atributos 'p√∫blicos' e 'privados'?**
- **P√∫blicos**: Podem ser acessados de qualquer parte do c√≥digo.
- **Privados**: S√≥ podem ser acessados dentro da pr√≥pria classe (em Dart, s√£o definidos com `_` antes do nome).

Exemplo:
```dart
class ContaBancaria {
  double _saldo = 1000; // Privado
  
  void depositar(double valor) {
    _saldo += valor;
  }
  
  double get saldo => _saldo; // M√©todo p√∫blico para acessar o saldo
}

void main() {
  ContaBancaria conta = ContaBancaria();
  print(conta.saldo); // Correto
  // print(conta._saldo); // Erro, pois _saldo √© privado
}
```

---

*Obs 7: Tendo em vista que a linguagem Dart n√£o possui suporte √† sobrecarga de m√©todos, o construtor nomeado veio para suprir
essa necessidade quando utilizados em classes. Obs: para atingir o mesmo efeito em fun√ß√µes (fora das classes), podem ser usados 
par√¢metros opcionais e nomeados*

### **7. Qual a diferen√ßa entre um construtor padr√£o e um construtor nomeado?**
- **Construtor padr√£o**: O m√©todo usado para criar um objeto quando **nenhum nome espec√≠fico** √© dado ao construtor.
- **Construtor nomeado**: Criado para oferecer diferentes maneiras de inicializar um objeto.

Exemplo:
```dart
class Carro {
  String marca;
  int ano;
  
  // Construtor padr√£o
  Carro(this.marca, this.ano);
  
  // Construtor nomeado
  Carro.novo(this.marca) {
    ano = DateTime.now().year;
  }
}

void main() {
  var carro1 = Carro("Ford", 2021);
  var carro2 = Carro.novo("Toyota"); // Usa o ano atual automaticamente
}
```

---

*Obs 8: *

### **8. O que s√£o 'factories' em Dart e quando devo us√°-las?**
**Factories** s√£o construtores que retornam uma **inst√¢ncia existente** ou criam um objeto de maneira mais complexa.
- S√£o √∫teis quando voc√™ **n√£o quer criar um novo objeto sempre** ou precisa **controlar a cria√ß√£o de inst√¢ncias**.

Exemplo:
```dart
class Singleton {
  static final Singleton _instancia = Singleton._interno();
  
  factory Singleton() {
    return _instancia;
  }
  
  Singleton._interno();
}

void main() {
  var obj1 = Singleton();
  var obj2 = Singleton();
  
  print(obj1 == obj2); // true, pois ambos s√£o a mesma inst√¢ncia
}
```

---

Essas s√£o as bases da orienta√ß√£o a objetos em Dart! üöÄ

Eu fiquei um pouco confuso nas quest√µes 7 e 8, ent√£o decidi fazer perguntar ao ChatGPT para me auxiliar no entendimento
desses conceitos.

Prompt: explique a fundo o conceito de construtores nomeadods

*Obs 7.1: Lendo isso, ficou mais claro o conceito e consegui entender o que s√£o os construtores nomeados e como us√°-los.
Entretanto, fiz mais algumas perguntas sobre eles*

### **Construtores Nomeados em Dart**

Construtores nomeados s√£o uma funcionalidade do Dart que permite criar m√∫ltiplos construtores dentro de uma mesma classe, cada um com uma funcionalidade espec√≠fica. Eles s√£o √∫teis quando h√° **diferentes maneiras de inicializar um objeto**, oferecendo mais flexibilidade do que apenas o construtor padr√£o.

---

## **üîπ Como Funciona um Construtor Nomeado?**
Um **construtor padr√£o** em Dart √© definido sem um nome espec√≠fico:
```dart
class Pessoa {
  String nome;
  int idade;

  Pessoa(this.nome, this.idade);
}
```
Agora, se quisermos permitir a cria√ß√£o de uma **Pessoa** sem precisar fornecer a idade, podemos criar um **construtor nomeado**:
```dart
class Pessoa {
  String nome;
  int idade;

  // Construtor padr√£o
  Pessoa(this.nome, this.idade);

  // Construtor nomeado
  Pessoa.apenasNome(this.nome) {
    idade = 0; // Definindo um valor padr√£o
  }
}

void main() {
  var p1 = Pessoa("Carlos", 30); // Usando o construtor padr√£o
  var p2 = Pessoa.apenasNome("Ana"); // Usando o construtor nomeado

  print("${p1.nome} tem ${p1.idade} anos"); // Carlos tem 30 anos
  print("${p2.nome} tem ${p2.idade} anos"); // Ana tem 0 anos
}
```
üìå **O que aconteceu aqui?**
- `Pessoa(this.nome, this.idade)`: Construtor **padr√£o**, inicializa todos os atributos.
- `Pessoa.apenasNome(this.nome)`: Construtor **nomeado**, define um nome e atribui um valor padr√£o para `idade`.

---

## **üîπ Vantagens dos Construtores Nomeados**
‚úÖ **Facilitam a leitura do c√≥digo** ‚Äì ao criar um objeto, fica claro qual m√©todo de inicializa√ß√£o est√° sendo usado.  
‚úÖ **Permitem diferentes formas de inicializa√ß√£o** ‚Äì voc√™ pode criar m√∫ltiplos m√©todos para inicializar objetos de maneiras variadas.  
‚úÖ **Evita a necessidade de m√∫ltiplas sobrecargas** ‚Äì j√° que Dart n√£o permite sobrecarga de construtores como em outras linguagens (Java, C++).

---

## **üîπ Exemplo com Diversos Construtores Nomeados**
```dart
class Carro {
  String marca;
  int ano;
  String tipo;

  // Construtor padr√£o
  Carro(this.marca, this.ano, this.tipo);

  // Construtor nomeado para carros novos
  Carro.novo(this.marca) {
    ano = DateTime.now().year; // Define o ano atual
    tipo = "Padr√£o";
  }

  // Construtor nomeado para SUVs
  Carro.suv(this.marca, this.ano) {
    tipo = "SUV";
  }
}

void main() {
  var carro1 = Carro("Ford", 2015, "Sedan");
  var carro2 = Carro.novo("Toyota");
  var carro3 = Carro.suv("Jeep", 2022);

  print("${carro1.marca} - ${carro1.ano} - ${carro1.tipo}"); // Ford - 2015 - Sedan
  print("${carro2.marca} - ${carro2.ano} - ${carro2.tipo}"); // Toyota - 2024 - Padr√£o
  print("${carro3.marca} - ${carro3.ano} - ${carro3.tipo}"); // Jeep - 2022 - SUV
}
```
üöÄ **Isso torna o c√≥digo mais flex√≠vel e reutiliz√°vel, pois diferentes tipos de carros podem ser criados com par√¢metros espec√≠ficos!**

---

## **üîπ Construtores Nomeados com Inicializa√ß√£o Inicial**
Dart tamb√©m permite que voc√™ inicialize atributos diretamente no **cabe√ßalho do construtor nomeado**. Isso pode tornar o c√≥digo mais curto e limpo:

```dart
class Usuario {
  String nome;
  String email;
  bool admin;

  // Construtor nomeado para criar um usu√°rio padr√£o
  Usuario.usuarioPadrao(this.nome, this.email) : admin = false;

  // Construtor nomeado para criar um administrador
  Usuario.admin(this.nome, this.email) : admin = true;
}

void main() {
  var u1 = Usuario.usuarioPadrao("Jo√£o", "joao@email.com");
  var u2 = Usuario.admin("Maria", "maria@email.com");

  print("${u1.nome} - Admin: ${u1.admin}"); // Jo√£o - Admin: false
  print("${u2.nome} - Admin: ${u2.admin}"); // Maria - Admin: true
}
```
üìå **Observe que n√£o usamos chaves `{}` nos construtores nomeados** porque a inicializa√ß√£o √© feita diretamente no cabe√ßalho.

---

## **üîπ Construtores Nomeados com `this` e Inicializa√ß√£o Diferenciada**
Voc√™ pode inicializar atributos de forma diferente, sem precisar definir vari√°veis dentro do corpo do construtor:
```dart
class Produto {
  String nome;
  double preco;
  bool emEstoque;

  Produto(this.nome, this.preco, this.emEstoque);

  // Construtor nomeado para produtos fora de estoque
  Produto.foraDeEstoque(this.nome, this.preco) : emEstoque = false;

  // Construtor nomeado para produtos em promo√ß√£o
  Produto.promocao(this.nome) : preco = 9.99, emEstoque = true;
}

void main() {
  var p1 = Produto("Cadeira", 150.0, true);
  var p2 = Produto.foraDeEstoque("Mesa", 200.0);
  var p3 = Produto.promocao("Caderno");

  print("${p1.nome} - R\$${p1.preco} - Estoque: ${p1.emEstoque}");
  print("${p2.nome} - R\$${p2.preco} - Estoque: ${p2.emEstoque}");
  print("${p3.nome} - R\$${p3.preco} - Estoque: ${p3.emEstoque}");
}
```
üîπ **Benef√≠cios dessa abordagem**:
- Permite inicializar atributos diretamente na lista de inicializa√ß√£o.
- Evita reatribui√ß√µes dentro do corpo do construtor.

---

## **üîπ Construtores Nomeados + `super` (Heran√ßa)**
Se uma classe herda de outra, os **construtores nomeados podem chamar o construtor da classe pai** com `super`:
```dart
class Animal {
  String nome;
  
  Animal(this.nome);
}

class Cachorro extends Animal {
  String raca;
  
  Cachorro.pastorAlemao() : raca = "Pastor Alem√£o", super("Rex");
}

void main() {
  var dog = Cachorro.pastorAlemao();
  print("${dog.nome} √© da ra√ßa ${dog.raca}"); // Rex √© da ra√ßa Pastor Alem√£o
}
```
üìå **Aqui, o construtor nomeado `pastorAlemao()` inicializa `raca` e chama o construtor da classe pai com `super`.**

---

## **üîπ Quando Usar Construtores Nomeados?**
üîπ **Para criar diferentes formas de inicializar um objeto** sem a necessidade de sobrecarga de m√©todos.  
üîπ **Quando h√° valores padr√£o que podem ser usados** para evitar repeti√ß√µes de c√≥digo.  
üîπ **Quando se deseja clareza na inten√ß√£o do c√≥digo** ‚Äì um construtor `Usuario.admin()` deixa claro que est√° criando um administrador.  
üîπ **Em conjunto com heran√ßa**, para controlar a cria√ß√£o de inst√¢ncias de subclasses.

---

## **üöÄ Conclus√£o**
Os **construtores nomeados** em Dart s√£o uma alternativa poderosa ao construtor padr√£o, oferecendo **mais flexibilidade e organiza√ß√£o** no c√≥digo. Eles permitem **m√∫ltiplas formas de inicializar objetos**, melhorando a **reutiliza√ß√£o e clareza** do c√≥digo.

Se tiver mais d√∫vidas, s√≥ perguntar! üöÄ

Prompt: ent√£o s√£o parecidos com o overload do java

*Obs 7.2: A d√∫vida se refere ao conceito da sobrecarga de m√©todos presente em linguagens como o Java. Em Dart, um efeito 
parecido pode ser atingido usando construtores nomeados*

Sim, os **construtores nomeados em Dart** s√£o uma alternativa ao **m√©todo de sobrecarga (overload) de construtores** do Java, pois permitem definir diferentes maneiras de instanciar uma classe.

### **üîπ Diferen√ßa principal entre Dart e Java**
- **Java permite sobrecarga de construtores** (m√©todos com o mesmo nome, mas assinaturas diferentes).
- **Dart n√£o suporta sobrecarga de construtores** diretamente, ent√£o utiliza **construtores nomeados** para suprir essa necessidade.

---

## **üî∏ Exemplo de Overload em Java**
Em Java, podemos definir **v√°rios construtores** com o **mesmo nome**, mas assinaturas diferentes:
```java
class Pessoa {
    String nome;
    int idade;

    // Construtor 1: Recebe nome e idade
    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    // Construtor 2: Apenas nome, define idade padr√£o
    public Pessoa(String nome) {
        this.nome = nome;
        this.idade = 0;
    }
}
```
‚úÖ **O compilador diferencia os construtores pelos tipos e quantidade de par√¢metros.**

---

## **üî∏ Como fazer isso em Dart?**
Dart n√£o permite sobrecarga de construtores, ent√£o usamos **construtores nomeados** para ter comportamentos diferentes:
```dart
class Pessoa {
  String nome;
  int idade;

  // Construtor padr√£o
  Pessoa(this.nome, this.idade);

  // Construtor nomeado que define um valor padr√£o para idade
  Pessoa.apenasNome(this.nome) : idade = 0;
}

void main() {
  var p1 = Pessoa("Carlos", 30);
  var p2 = Pessoa.apenasNome("Ana");

  print("${p1.nome} tem ${p1.idade} anos"); // Carlos tem 30 anos
  print("${p2.nome} tem ${p2.idade} anos"); // Ana tem 0 anos
}
```
‚úÖ **O resultado √© o mesmo do Java, mas Dart obriga a usar nomes diferentes para cada construtor.**

---

## **üî∏ Resumo**
| Caracter√≠stica        | Java (Overload) | Dart (Construtores Nomeados) |
|----------------------|----------------|------------------------------|
| Construtores com o mesmo nome | ‚úÖ Sim | ‚ùå N√£o |
| Diferencia√ß√£o por par√¢metros | ‚úÖ Sim | ‚ùå N√£o (precisa de nomes diferentes) |
| Alternativa para sobrecarga | - | ‚úÖ Usa construtores nomeados |
| Melhor legibilidade | ‚ö†Ô∏è Pode ficar confuso | ‚úÖ Mais claro |

Se precisar de mais detalhes, s√≥ perguntar! üöÄ

Prompt: √© poss√≠vel atingir esse mesmo efeito mas fora das classes

*Obs 7.3: Eu fiquei curioso para saber se era poss√≠vel ter um efeito parecido com os dos construtores nomeados em fun√ß√µes
fora das classes, ent√£o perguntei √† IA. Com a resposta, ficou ainda mais claro o porqu√™ dos par√¢metros opcionais e nomeados 
existirem, pois eu pensava que eram apenas para melhorar a legibilidade e manutenibilidade do c√≥digo*

Em Dart, **n√£o √© poss√≠vel criar duas fun√ß√µes com o mesmo nome na mesma classe ou no mesmo escopo**, pois Dart **n√£o suporta sobrecarga de m√©todos** como Java faz.

No entanto, existem **tr√™s formas alternativas** de conseguir um efeito parecido:

---

## **1Ô∏è‚É£ Usar Par√¢metros Opcionais e Nomeados**
üí° **A solu√ß√£o mais comum em Dart √© usar par√¢metros opcionais/nomeados para permitir diferentes formas de chamar a mesma fun√ß√£o.**

```dart
void saudacao(String nome, {int? idade}) {
  if (idade != null) {
    print("Ol√°, $nome! Voc√™ tem $idade anos.");
  } else {
    print("Ol√°, $nome!");
  }
}

void main() {
  saudacao("Carlos", idade: 30); // Ol√°, Carlos! Voc√™ tem 30 anos.
  saudacao("Ana");               // Ol√°, Ana!
}
```
üîπ Aqui, `idade` √© opcional. Se for passado, a sa√≠da √© diferente.  
üîπ Isso evita criar duas fun√ß√µes com nomes diferentes, mantendo um c√≥digo limpo.

---

## **2Ô∏è‚É£ Usar Fun√ß√µes de Alta Ordem (Closures)**
Se precisar de um comportamento mais avan√ßado, pode usar **fun√ß√µes an√¥nimas ou closures**.

```dart
Function criarSaudacao(bool formal) {
  if (formal) {
    return (String nome) => print("Muito prazer, Sr. $nome.");
  } else {
    return (String nome) => print("E a√≠, $nome!");
  }
}

void main() {
  var saudacaoFormal = criarSaudacao(true);
  var saudacaoCasual = criarSaudacao(false);

  saudacaoFormal("Carlos"); // Muito prazer, Sr. Carlos.
  saudacaoCasual("Ana");    // E a√≠, Ana!
}
```
üîπ Aqui, `criarSaudacao` retorna uma **fun√ß√£o diferente** dependendo da necessidade.

---

## **3Ô∏è‚É£ Criar M√©todos Est√°ticos Diferentes em uma Classe**
Se quiser simular **sobreposi√ß√£o de m√©todos como em Java**, pode criar **m√©todos est√°ticos** com nomes diferentes dentro de uma classe.

```dart
class Mensagem {
  static void exibir(String texto) {
    print(texto);
  }

  static void exibirComAutor(String texto, String autor) {
    print("$texto - $autor");
  }
}

void main() {
  Mensagem.exibir("Ol√°, mundo!"); 
  Mensagem.exibirComAutor("Ol√°, mundo!", "Gustavo");
}
```
üîπ Aqui, `exibir` e `exibirComAutor` t√™m nomes diferentes, mas fazem parte da mesma l√≥gica.

---

## **üîπ Resumo**
Dart **n√£o permite sobrecarga de fun√ß√µes/m√©todos**, mas voc√™ pode contornar isso com:  
‚úî **Par√¢metros opcionais e nomeados** ‚úÖ Mais usado  
‚úî **Fun√ß√µes que retornam outras fun√ß√µes (closures)** ‚úÖ Flex√≠vel  
‚úî **M√©todos est√°ticos diferentes dentro de uma classe** ‚úÖ Simula sobrecarga

Se precisar de algo mais espec√≠fico, s√≥ perguntar! üöÄ

Prompt: explique a fundo o conceito de factories 

*Obs 8.1: Gra√ßas √† IA, pude aprender um conceito novo que ainda n√£o foi apresentado no curso. Em um dos exemplos, a IA
utilizou uma classe nomeada Singleton, e logo me veio √† mente o padr√£o de projeto singleton, que possui um conceito 
muito parecido com o da classe implementada pela IA utilizando factories*

### **Factories em Dart ‚Äì Conceito e Uso Profundo üöÄ**

Em Dart, uma **factory** (f√°brica) √© um tipo especial de **construtor** que **n√£o cria sempre uma nova inst√¢ncia** da classe. Ele pode:

‚úÖ **Retornar um objeto j√° existente**  
‚úÖ **Criar um objeto de um tipo diferente da classe base**  
‚úÖ **Encapsular l√≥gica complexa antes de criar uma inst√¢ncia**

Factories s√£o usadas quando **o construtor normal (`class Nome { Nome(); }`) n√£o √© suficiente para criar um objeto da maneira desejada.**

---

## **1Ô∏è‚É£ Sintaxe B√°sica de um Factory**
Diferente de um construtor normal, um **construtor factory** usa a palavra-chave `factory` e pode retornar um objeto j√° criado:

```dart
class Pessoa {
  String nome;
  int idade;

  // Construtor normal
  Pessoa(this.nome, this.idade);

  // Construtor factory
  factory Pessoa.crianca(String nome) {
    return Pessoa(nome, 10); // Sempre retorna um objeto com idade = 10
  }
}

void main() {
  var p1 = Pessoa("Carlos", 25); // Construtor normal
  var p2 = Pessoa.crianca("Ana"); // Construtor factory

  print("${p1.nome}, ${p1.idade} anos"); // Carlos, 25 anos
  print("${p2.nome}, ${p2.idade} anos"); // Ana, 10 anos
}
```
üîπ O m√©todo `Pessoa.crianca()` sempre cria uma inst√¢ncia com `idade = 10`, simplificando a l√≥gica.

---

## **2Ô∏è‚É£ Factory para Controlar Inst√¢ncias (Singleton)**
Factories s√£o √∫teis para **garantir que sempre ser√° retornado o mesmo objeto** ao inv√©s de criar novas inst√¢ncias.

### **üîπ Implementa√ß√£o de Singleton com Factory**
```dart
class Configuracao {
  static final Configuracao _instancia = Configuracao._interno();

  String tema = "claro"; 

  // Construtor privado
  Configuracao._interno();

  // Factory retorna sempre a mesma inst√¢ncia
  factory Configuracao() {
    return _instancia;
  }
}

void main() {
  var c1 = Configuracao();
  var c2 = Configuracao();

  c1.tema = "escuro"; 

  print(c2.tema); // escuro (c2 e c1 s√£o o mesmo objeto!)
}
```
üîπ `Configuracao._interno()` cria a **√∫nica** inst√¢ncia, e `factory Configuracao()` **sempre retorna a mesma**.

---

## **3Ô∏è‚É£ Factory para Retornar Objetos de Diferentes Tipos**
Factories podem retornar **subclasses** ou mesmo **objetos totalmente diferentes**!

```dart
abstract class Animal {
  factory Animal(String tipo) {
    if (tipo == "cachorro") return Cachorro();
    if (tipo == "gato") return Gato();
    throw ArgumentError("Tipo desconhecido");
  }
}

class Cachorro implements Animal {
  void som() => print("Au Au!");
}

class Gato implements Animal {
  void som() => print("Miau!");
}

void main() {
  var pet1 = Animal("cachorro");
  var pet2 = Animal("gato");

  (pet1 as Cachorro).som(); // Au Au!
  (pet2 as Gato).som();     // Miau!
}
```
üîπ O `factory Animal` decide **qual classe instanciar**, funcionando como um "m√©todo-f√°brica".

---

## **4Ô∏è‚É£ Factory para Criar Objetos com Cache**
Se precisar que objetos sejam **cri√°veis apenas uma vez por valor**, um **cache interno** ajuda:

```dart
class Usuario {
  final String nome;
  static final Map<String, Usuario> _cache = {};

  // Factory que reutiliza inst√¢ncias j√° criadas
  factory Usuario(String nome) {
    return _cache.putIfAbsent(nome, () => Usuario._interno(nome));
  }

  Usuario._interno(this.nome);
}

void main() {
  var u1 = Usuario("Alice");
  var u2 = Usuario("Alice");
  var u3 = Usuario("Bob");

  print(identical(u1, u2)); // true (mesma inst√¢ncia)
  print(identical(u1, u3)); // false (inst√¢ncias diferentes)
}
```
üîπ `putIfAbsent` impede que dois objetos com o mesmo nome sejam criados, retornando o j√° existente.

---

## **üìå Resumo Final**
| **Funcionalidade** | **Explica√ß√£o** |
|------------------|--------------|
| `factory` | Permite que um construtor retorne objetos j√° existentes ou diferentes da classe |
| **Evita sempre criar novas inst√¢ncias** | Como um Singleton, retorna sempre o mesmo objeto |
| **Decide qual classe instanciar** | Pode retornar diferentes subclasses dependendo do argumento |
| **Gerencia cache interno** | Pode reutilizar inst√¢ncias para otimizar mem√≥ria |

Factories s√£o **muito √∫teis quando voc√™ precisa de mais controle sobre a cria√ß√£o de objetos**! üöÄ
